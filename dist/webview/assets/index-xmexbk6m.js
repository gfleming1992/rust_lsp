var O=Object.defineProperty;var U=(S,e,t)=>e in S?O(S,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[e]=t;var i=(S,e,t)=>(U(S,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();class P{constructor(){i(this,"state",{panX:0,panY:0,zoom:1,flipX:!1,flipY:!0,dragging:!1,dragButton:null,lastX:0,lastY:0,needsDraw:!0});i(this,"layerRenderData",new Map);i(this,"layerInfoMap",new Map);i(this,"layerOrder",[]);i(this,"layerColors",new Map);i(this,"layerVisible",new Map);i(this,"colorOverrides",new Map);i(this,"viasVisible",!0);i(this,"device",null);i(this,"pipelines",null);i(this,"uniformData",new Float32Array(16));i(this,"BASE_PALETTE",[[.95,.95,.95,1],[.95,.2,.2,1],[.2,.8,.2,1],[.3,.6,1,1],[1,.85,.2,1],[1,.4,.75,1],[.95,.55,.2,1],[.8,.3,1,1],[.2,.9,.9,1],[1,.6,.3,1],[.5,1,.3,1],[.3,.4,.8,1],[.9,.5,.7,1],[.7,.9,.5,1],[.5,.7,.9,1],[.9,.7,.4,1]]);i(this,"STORAGE_KEY","layerColorOverrides");this.loadColorOverrides()}setDevice(e,t){this.device=e,this.pipelines=t}getLayerColor(e){if(!this.layerColors.has(e)){const t=this.layerInfoMap.get(e);let r;t?r=[...t.defaultColor]:r=[...this.BASE_PALETTE[this.hashStr(e)%this.BASE_PALETTE.length]],this.colorOverrides.has(e)&&(r=[...this.colorOverrides.get(e)]),this.layerColors.set(e,r),this.layerVisible.has(e)||this.layerVisible.set(e,!0)}return this.layerColors.get(e)}setLayerColor(e,t){this.layerColors.set(e,t),this.colorOverrides.set(e,t),this.saveColorOverride(e,t),this.state.needsDraw=!0}resetLayerColor(e){this.layerColors.delete(e),this.colorOverrides.delete(e),this.removeColorOverride(e),this.state.needsDraw=!0}toggleLayerVisibility(e,t){this.layerVisible.set(e,t),this.state.needsDraw=!0}loadLayerData(e){const t=performance.now();if(!this.device||!this.pipelines){console.warn("Cannot load layer data: Device or pipelines not set");return}const r=e.layerId,n=e.layerName||r,s=[...e.defaultColor??[.8,.8,.8,1]];this.layerInfoMap.set(r,{id:r,name:n,defaultColor:s}),this.layerOrder.includes(r)||this.layerOrder.push(r),this.layerColors.has(r)||this.layerColors.set(r,[...s]),this.layerVisible.has(r)||this.layerVisible.set(r,!0);const a=[["batch",e.geometry.batch],["batch_colored",e.geometry.batch_colored],["batch_instanced",e.geometry.batch_instanced],["batch_instanced_rot",e.geometry.batch_instanced_rot],["instanced_rot_colored",e.geometry.instanced_rot_colored],["instanced_rot",e.geometry.instanced_rot],["instanced_colored",e.geometry.instanced_colored],["instanced",e.geometry.instanced],["basic",e.geometry.basic]];let l=!1;for(const[m,x]of a){if(!x||x.length===0)continue;l=!0;const o=m==="batch"?e.layerId:`${e.layerId}_${m}`;m==="instanced"||m==="instanced_rot"?this.loadInstancedGeometry(e,o,m,x):this.loadGeometryType(e,o,m,x)}l||console.warn(`No geometry data found for layer ${e.layerId}`);const B=performance.now();console.log(`[SCENE] Loaded ${e.layerId} in ${(B-t).toFixed(1)}ms`),this.state.needsDraw=!0}loadGeometryType(e,t,r,n){if(!this.device||!this.pipelines)return;const s=[],a=[],l=[],B=[],m=[];for(let f=0;f<n.length;f++){const d=n[f];if(!d)continue;const u=atob(d.vertexData),v=new Uint8Array(u.length);for(let p=0;p<u.length;p++)v[p]=u.charCodeAt(p);const y=new Float32Array(v.buffer),w=this.device.createBuffer({size:y.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(w.getMappedRange()).set(y),w.unmap(),s.push(w),l.push(d.vertexCount);let g;if(d.alphaData){const p=atob(d.alphaData),C=new Uint8Array(p.length);for(let E=0;E<p.length;E++)C[E]=p.charCodeAt(E);g=new Float32Array(C.buffer)}else g=new Float32Array(d.vertexCount),g.fill(1);const h=this.device.createBuffer({size:g.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(h.getMappedRange()).set(g),h.unmap(),a.push(h),d.indexData&&d.indexCount&&d.indexCount>0){const p=atob(d.indexData),C=new Uint8Array(p.length);for(let L=0;L<p.length;L++)C[L]=p.charCodeAt(L);const E=new Uint32Array(C.buffer),A=this.device.createBuffer({size:E.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(A.getMappedRange()).set(E),A.unmap(),B.push(A),m.push(d.indexCount)}else B.push(null),m.push(0)}const x=this.getLayerColor(e.layerId);this.uniformData.set(x,0);const o=this.device.createBuffer({size:this.uniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),b=r==="batch"?this.pipelines.noAlpha:this.pipelines.withAlpha,c=this.device.createBindGroup({layout:b.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}}]});this.layerRenderData.set(t,{layerId:e.layerId,shaderType:r,lodBuffers:s,lodAlphaBuffers:a,lodVertexCounts:l,lodIndexBuffers:B,lodIndexCounts:m,currentLOD:0,uniformBuffer:o,bindGroup:c})}loadInstancedGeometry(e,t,r,n){if(!this.device||!this.pipelines)return;const s=[],a=[],l=[],B=[],m=[],x=[];for(let d=0;d<n.length;d++){const u=n[d];if(!u)continue;const v=atob(u.vertexData),y=new Uint8Array(v.length);for(let h=0;h<v.length;h++)y[h]=v.charCodeAt(h);const w=new Float32Array(y.buffer),g=this.device.createBuffer({size:w.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(g.getMappedRange()).set(w),g.unmap(),s.push(g),l.push(u.vertexCount),u.instanceData&&u.instanceCount){const h=atob(u.instanceData),p=new Uint8Array(h.length);for(let A=0;A<h.length;A++)p[A]=h.charCodeAt(A);const C=new Float32Array(p.buffer),E=this.device.createBuffer({size:C.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(E.getMappedRange()).set(C),E.unmap(),a.push(E),B.push(u.instanceCount)}else{const h=this.device.createBuffer({size:4,usage:GPUBufferUsage.VERTEX});a.push(h),B.push(0)}if(u.indexData&&u.indexCount&&u.indexCount>0){const h=atob(u.indexData),p=new Uint8Array(h.length);for(let A=0;A<h.length;A++)p[A]=h.charCodeAt(A);const C=new Uint32Array(p.buffer),E=this.device.createBuffer({size:C.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(E.getMappedRange()).set(C),E.unmap(),m.push(E),x.push(u.indexCount)}else m.push(null),x.push(0)}const o=this.getLayerColor(e.layerId);this.uniformData.set(o,0);const b=this.device.createBuffer({size:this.uniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),c=r==="instanced"?this.pipelines.instanced:this.pipelines.instancedRot,f=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b}}]});this.layerRenderData.set(t,{layerId:e.layerId,shaderType:r,lodBuffers:s,lodInstanceBuffers:a,lodAlphaBuffers:[],lodVertexCounts:l,lodInstanceCounts:B,lodIndexBuffers:m,lodIndexCounts:x,currentLOD:0,uniformBuffer:b,bindGroup:f})}hashStr(e){let t=2166136261;for(let r=0;r<e.length;r+=1)t^=e.charCodeAt(r),t=Math.imul(t,16777619);return t>>>0}saveColorOverride(e,t){try{const r=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");r[e]=t,localStorage.setItem(this.STORAGE_KEY,JSON.stringify(r))}catch(r){console.error("Failed to save color override",r)}}removeColorOverride(e){try{const t=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");delete t[e],localStorage.setItem(this.STORAGE_KEY,JSON.stringify(t))}catch(t){console.error("Failed to remove color override",t)}}loadColorOverrides(){try{const e=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");for(const[t,r]of Object.entries(e))Array.isArray(r)&&r.length===4&&(this.colorOverrides.set(t,[...r]),this.layerColors.set(t,[...r]))}catch(e){console.error("Failed to load color overrides",e)}}}const _=`// Basic shader for rendering simple shapes with optional per-vertex alpha\r
// Supports lines, arcs, outlines, polygons, polylines, fills\r
// Consolidated from: line.wgsl, arc.wgsl, outline.wgsl, polygon.wgsl, polyline.wgsl\r
// Alpha defaults to 1.0 (layer color) when no alpha buffer is provided\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) vertAlpha : f32) -> VSOut {\r
  var out : VSOut;\r
  let p = vec3<f32>(pos, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  // Combine layer RGB (from uniform) with per-vertex alpha\r
  out.color = vec4<f32>(U.color.xyz, vertAlpha);\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,D=`// Basic shader without per-vertex alpha (always uses layer color alpha)\r
// For rendering polylines and shapes that don't need transparency variation\r
// Optimized: no alpha buffer required, saves memory and attribute fetching\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>) -> VSOut {\r
  var out : VSOut;\r
  let p = vec3<f32>(pos, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  // Use layer color directly (RGB + A from uniform)\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,F=`// Instanced shader for rendering repeated identical geometry at different positions.\r
// Supports per-instance translation offset.\r
// Consolidated from: polygon_instanced.wgsl, polyline_instanced.wgsl\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) instOff : vec2<f32>) -> VSOut {\r
  var out : VSOut;\r
  // Apply per-instance translation in model space before view * model inside uniforms (we baked model*view already) -> instead, translate in clip by reconstructing before row multiply\r
  // Simpler: treat translation as added to position prior to matrix multiply (matrix encodes view, so we need to apply same linear part). We'll extend pos with 1 and rely on matrix rows.\r
  let p = vec3<f32>(pos + instOff, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,T=`// Instanced shader with rotation support.\r
// For rendering repeated geometry at different positions with arbitrary rotations.\r
// Instance data: vec3<f32> = (offsetX, offsetY, rotationRadians)\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) inst : vec3<f32>) -> VSOut {\r
  var out : VSOut;\r
  \r
  // Extract rotation angle in radians\r
  let angle = inst.z;\r
  let c = cos(angle);\r
  let s = sin(angle);\r
  \r
  // Apply rotation\r
  let rotated = vec2<f32>(\r
    pos.x * c - pos.y * s,\r
    pos.x * s + pos.y * c\r
  );\r
  \r
  // Apply translation and transform\r
  let p = vec3<f32>(rotated + inst.xy, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`;class V{constructor(e,t){i(this,"canvas");i(this,"device");i(this,"context");i(this,"pipelineNoAlpha");i(this,"pipelineWithAlpha");i(this,"pipelineInstanced");i(this,"pipelineInstancedRot");i(this,"canvasFormat");i(this,"configuredWidth",0);i(this,"configuredHeight",0);i(this,"uniformData",new Float32Array(16));i(this,"lastVertexCount",0);i(this,"lastIndexCount",0);i(this,"frameCount",0);i(this,"lastFpsUpdate",performance.now());i(this,"lastFps",0);i(this,"scene");i(this,"gpuMemoryBytes",0);i(this,"gpuBuffers",[]);this.canvas=e,this.scene=t}async init(){const e=navigator.gpu;if(!e)throw new Error("WebGPU is not available in this browser");const t=await e.requestAdapter();if(!t)throw new Error("Unable to acquire WebGPU adapter");this.device=await t.requestDevice(),this.wrapCreateBuffer(this.device);const r=this.canvas.getContext("webgpu");if(!r)throw new Error("Failed to acquire WebGPU context");this.context=r,this.canvasFormat=e.getPreferredCanvasFormat(),this.createPipelines(),this.scene.setDevice(this.device,{noAlpha:this.pipelineNoAlpha,withAlpha:this.pipelineWithAlpha,instanced:this.pipelineInstanced,instancedRot:this.pipelineInstancedRot}),new ResizeObserver(()=>{this.configureSurface(),this.scene.state.needsDraw=!0}).observe(this.canvas),window.addEventListener("resize",()=>{this.configureSurface(),this.scene.state.needsDraw=!0})}createPipelines(){const e=this.device.createShaderModule({code:_}),t=this.device.createShaderModule({code:D}),r=this.device.createShaderModule({code:F}),n=this.device.createShaderModule({code:T});this.pipelineWithAlpha=this.device.createRenderPipeline({layout:"auto",vertex:{module:e,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:1*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:1,offset:0,format:"float32"}]}]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineNoAlpha=this.device.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineInstanced=this.device.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineInstancedRot=this.device.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x3"}]}]},fragment:{module:n,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}})}wrapCreateBuffer(e){if(e.__wrappedCreateBuffer)return;const t=e.createBuffer.bind(e);e.createBuffer=r=>{const n=t(r),s=r.size??0;return this.gpuMemoryBytes+=s,this.gpuBuffers.push({buffer:n,size:s}),n},e.__wrappedCreateBuffer=!0}configureSurface(){const e=window.devicePixelRatio||1,t=Math.max(1,Math.floor(this.canvas.clientWidth*e)),r=Math.max(1,Math.floor(this.canvas.clientHeight*e));this.canvas.width!==t&&(this.canvas.width=t),this.canvas.height!==r&&(this.canvas.height=r),!(t===this.configuredWidth&&r===this.configuredHeight)&&(this.configuredWidth=t,this.configuredHeight=r,this.context.configure({device:this.device,format:this.canvasFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT}))}updateUniforms(){const e=Math.max(1,this.canvas.width),t=Math.max(1,this.canvas.height),r=this.scene.state,n=r.flipX?-1:1,s=r.flipY?-1:1,a=2*r.zoom/e,l=2*r.zoom/t,B=a*(e/2+r.panX)-1,m=1-l*(t/2+r.panY);this.uniformData[4]=n*a,this.uniformData[5]=0,this.uniformData[6]=n*B,this.uniformData[7]=0,this.uniformData[8]=0,this.uniformData[9]=s*-l,this.uniformData[10]=s>0?m:-m,this.uniformData[11]=0,this.uniformData[12]=0,this.uniformData[13]=0,this.uniformData[14]=1,this.uniformData[15]=0}selectLODForZoom(e){return e>=10?0:e>=5?1:e>=2?2:e>=.5?3:4}screenToWorld(e,t){const r=Math.max(1,this.canvas.width),n=Math.max(1,this.canvas.height),s=this.scene.state,a=s.flipX?-1:1,l=s.flipY?-1:1,B=2*s.zoom/r,m=2*s.zoom/n,x=2*e/Math.max(1,this.canvas.clientWidth)-1,o=1-2*t/Math.max(1,this.canvas.clientHeight),b=(x/a+1)/B-r/2-s.panX,c=(1-o*l)/m-n/2-s.panY;return{x:b,y:c}}render(){if(!this.scene.state.needsDraw)return;this.scene.state.needsDraw=!1,this.configureSurface(),this.updateUniforms();const e=this.selectLODForZoom(this.scene.state.zoom),t=this.device.createCommandEncoder(),r=this.context.getCurrentTexture().createView(),n=t.beginRenderPass({colorAttachments:[{view:r,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});let s=0,a=0;for(const m of this.scene.layerOrder)if(this.scene.layerVisible.get(m)!==!1)for(const[x,o]of this.scene.layerRenderData.entries()){if(o.layerId!==m||x.endsWith("_instanced"))continue;if(o.shaderType==="instanced_rot"){const u=o.lodBuffers.length,v=u/3,y=e*v,w=y+v;n.setPipeline(this.pipelineInstancedRot);for(let g=y;g<w&&g<u;g++){const h=o.lodBuffers[g],p=o.lodVertexCounts[g],C=o.lodInstanceBuffers?.[g],E=o.lodInstanceCounts?.[g]??0;if(!h||!p||!C||E===0)continue;n.setVertexBuffer(0,h),n.setVertexBuffer(1,C);const A=this.scene.getLayerColor(o.layerId);this.uniformData.set(A,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),n.setBindGroup(0,o.bindGroup);const L=o.lodIndexBuffers?.[g],M=o.lodIndexCounts?.[g]??0;L&&M>0?(n.setIndexBuffer(L,"uint32"),n.drawIndexed(M,E),a+=M*E):n.draw(p,E)}continue}const b=Math.min(e,o.lodBuffers.length-1),c=o.lodBuffers[b],f=o.lodVertexCounts[b];if(!c||!f)continue;s+=f;let d;if(o.shaderType==="batch"?d=this.pipelineNoAlpha:x.endsWith("_instanced")?d=this.pipelineInstanced:d=this.pipelineWithAlpha,n.setPipeline(d),n.setVertexBuffer(0,c),x.endsWith("_instanced")){const u=o.lodInstanceBuffers?.[b],v=o.lodInstanceCounts?.[b]??0;if(u&&v>0){n.setVertexBuffer(1,u);const y=this.scene.getLayerColor(o.layerId);this.uniformData.set(y,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),n.setBindGroup(0,o.bindGroup);const w=o.lodIndexBuffers?.[b]??null,g=o.lodIndexCounts?.[b]??0;w&&g>0?(n.setIndexBuffer(w,"uint32"),n.drawIndexed(g,v),a+=g*v):n.draw(f,v)}}else{if(o.shaderType!=="batch"){const w=o.lodAlphaBuffers[b];w&&n.setVertexBuffer(1,w)}const u=this.scene.getLayerColor(o.layerId);this.uniformData.set(u,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),n.setBindGroup(0,o.bindGroup);const v=o.lodIndexBuffers?.[b]??null,y=o.lodIndexCounts?.[b]??0;v&&y>0?(n.setIndexBuffer(v,"uint32"),n.drawIndexed(y),a+=y):n.draw(f)}}const l=Array.from(this.scene.layerVisible.values()).some(m=>m);if(this.scene.viasVisible&&l){const m=[1,.9,.25,1];for(const[x,o]of this.scene.layerRenderData.entries()){if(!x.endsWith("_instanced"))continue;const b=o.lodBuffers.length,c=b/3;if(e>=3)continue;const f=e*c,d=f+c;for(let u=f;u<d&&u<b;u++){const v=o.lodBuffers[u],y=o.lodVertexCounts[u];if(!v||!y||y===0)continue;const w=o.lodInstanceBuffers?.[u],g=o.lodInstanceCounts?.[u]??0;if(!w||g===0)continue;n.setPipeline(this.pipelineInstanced),n.setVertexBuffer(0,v),n.setVertexBuffer(1,w),this.uniformData.set(m,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),n.setBindGroup(0,o.bindGroup);const h=o.lodIndexBuffers?.[u]??null,p=o.lodIndexCounts?.[u]??0;h&&p>0?(n.setIndexBuffer(h,"uint32"),n.drawIndexed(p,g)):n.draw(y,g)}}}n.end(),this.device.queue.submit([t.finish()]),this.lastVertexCount=s,this.lastIndexCount=a,this.frameCount+=1;const B=performance.now();B-this.lastFpsUpdate>=1e3&&(this.lastFps=this.frameCount*1e3/(B-this.lastFpsUpdate),this.frameCount=0,this.lastFpsUpdate=B)}}class R{constructor(e,t){i(this,"scene");i(this,"renderer");i(this,"layersEl",null);i(this,"coordOverlayEl",null);i(this,"fpsEl",null);i(this,"debugLogEl",null);i(this,"lastStatsUpdate",0);this.scene=e,this.renderer=t,this.layersEl=document.getElementById("layers"),this.coordOverlayEl=document.getElementById("coordOverlay"),this.fpsEl=document.getElementById("fps"),this.debugLogEl=document.getElementById("debugLog"),this.interceptConsoleLog(this.debugLogEl)}interceptConsoleLog(e){e&&console.log("[LOGGING] Browser DevTools console is the primary log output")}refreshLayerLegend(){if(!this.layersEl)return;const e=[];e.push(`
      <div style="margin-bottom:4px; display:flex; gap:4px; flex-wrap:wrap; font:11px sans-serif;">
        <button type="button" data-layer-action="all" style="padding:2px 6px;">All</button>
        <button type="button" data-layer-action="none" style="padding:2px 6px;">None</button>
        <button type="button" data-layer-action="invert" style="padding:2px 6px;">Invert</button>
      </div>
    `);const t=this.scene.layerOrder.map(r=>[r,this.scene.getLayerColor(r)]);e.push("<div>");for(const[r,n]of t){const s=this.scene.layerVisible.get(r)!==!1;e.push(this.createLegendRow(r,n,s))}e.push("</div>"),this.layersEl.innerHTML=e.join(""),this.layersEl.querySelectorAll("button[data-layer-action]").forEach(r=>{r.addEventListener("click",n=>{const s=n.currentTarget.dataset.layerAction;if(s==="all")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,!0);else if(s==="none")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,!1);else if(s==="invert")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,this.scene.layerVisible.get(a)===!1);this.refreshLayerLegend(),this.scene.state.needsDraw=!0})}),this.layersEl.querySelectorAll("input[data-layer-toggle]").forEach(r=>{r.addEventListener("change",n=>{const s=n.currentTarget,a=s.dataset.layerToggle;a&&this.scene.toggleLayerVisibility(a,s.checked)})}),this.layersEl.querySelectorAll("button[data-layer-color]").forEach(r=>{r.addEventListener("click",()=>{const n=r.dataset.layerColor;if(!n)return;const s=this.scene.getLayerColor(n);this.showColorPicker(n,s)})})}createLegendRow(e,t,r){const n=`rgba(${Math.round(t[0]*255)}, ${Math.round(t[1]*255)}, ${Math.round(t[2]*255)}, 1)`,s=this.scene.layerInfoMap.get(e),a=s?s.name:e;return`
      <div class="layer-entry" data-layer="${e}" style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
        <input type="checkbox" data-layer-toggle="${e}" ${r?"checked":""} style="margin:0" />
        <button type="button" data-layer-color="${e}" title="Change color" style="width:18px;height:18px;border:1px solid #444;border-radius:3px;background:${n};"></button>
        <span style="flex:1 1 auto; font-size:11px;">${a}</span>
      </div>
    `}showColorPicker(e,t){document.getElementById("colorPickerModal")?.remove();const n=document.createElement("div");n.id="colorPickerModal",n.style.cssText="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:10000;";const s=document.createElement("div");s.style.cssText="background:#2b2b2b; padding:20px; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.5);";const a=(c,f,d)=>`rgb(${Math.round(c*255)},${Math.round(f*255)},${Math.round(d*255)})`;let l=`<div style="color:#fff; font:14px sans-serif; margin-bottom:12px;">Pick color for <strong>${e}</strong></div>`;l+='<div style="display:grid; grid-template-columns:repeat(16, 24px); gap:2px; margin-bottom:12px;">';for(let c=0;c<16;c+=1){const f=c/15,d=a(f,f,f);l+=`<div class="color-cell" data-color="${f},${f},${f}" style="width:24px; height:24px; background:${d}; cursor:pointer; border:1px solid #444;"></div>`}for(let c=0;c<12;c+=1)for(let f=0;f<16;f+=1){const d=f/16*360,u=.3+c/11*.7,v=.3+f%2*.2+c%3*.15,y=(1-Math.abs(2*v-1))*u,w=y*(1-Math.abs(d/60%2-1)),g=v-y/2;let h=0,p=0,C=0;d<60?(h=y,p=w,C=0):d<120?(h=w,p=y,C=0):d<180?(h=0,p=y,C=w):d<240?(h=0,p=w,C=y):d<300?(h=w,p=0,C=y):(h=y,p=0,C=w),h+=g,p+=g,C+=g;const E=a(h,p,C);l+=`<div class="color-cell" data-color="${h},${p},${C}" style="width:24px; height:24px; background:${E}; cursor:pointer; border:1px solid #444;"></div>`}l+="</div>";const B=[0,1,2].map(c=>Math.round(t[c]*255).toString(16).padStart(2,"0")).join("");l+='<div style="display:flex; gap:10px; align-items:center; margin-bottom:12px;">',l+='<div style="color:#aaa; font:12px sans-serif;">Current:</div>',l+=`<div style="width:40px; height:24px; background:${a(t[0],t[1],t[2])}; border:1px solid #444;"></div>`,l+='<button id="resetColorBtn" style="padding:4px 10px; background:#555; color:#fff; border:none; border-radius:3px; cursor:pointer; font:11px sans-serif;">Reset to Default</button>',l+="</div>",l+='<div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">',l+='<div style="display:flex; gap:6px; align-items:center;">',l+='<label style="color:#aaa; font:11px sans-serif;">#</label>',l+=`<input type="text" id="hexColorInput" value="${B}" maxlength="6" style="width:80px; padding:6px 8px; background:#1a1a1a; color:#fff; border:1px solid #555; border-radius:3px; font:12px monospace; text-transform:uppercase;" />`,l+='<button id="applyCustomBtn" style="padding:6px 12px; background:#4a9eff; color:#fff; border:none; border-radius:3px; cursor:pointer; font:11px sans-serif;">Apply</button>',l+="</div>",l+='<button id="cancelColorBtn" style="padding:6px 14px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer; font:12px sans-serif;">Cancel</button>',l+="</div>",s.innerHTML=l,n.appendChild(s),document.body.appendChild(n),s.querySelectorAll(".color-cell").forEach(c=>{c.addEventListener("click",f=>{const d=f.currentTarget.dataset.color;if(!d)return;const[u,v,y]=d.split(",").map(parseFloat),w=[u,v,y,1];this.scene.setLayerColor(e,w),this.refreshLayerLegend(),n.remove()})});const m=document.getElementById("applyCustomBtn"),x=document.getElementById("hexColorInput");m?.addEventListener("click",()=>{if(!x)return;const c=x.value.replace(/[^0-9a-fA-F]/g,"");if(c.length===6){const f=parseInt(c.slice(0,2),16)/255,d=parseInt(c.slice(2,4),16)/255,u=parseInt(c.slice(4,6),16)/255,v=[f,d,u,1];this.scene.setLayerColor(e,v),this.refreshLayerLegend(),n.remove()}}),document.getElementById("resetColorBtn")?.addEventListener("click",()=>{this.scene.resetLayerColor(e),this.refreshLayerLegend(),n.remove()}),document.getElementById("cancelColorBtn")?.addEventListener("click",()=>n.remove()),n.addEventListener("click",c=>{c.target===n&&n.remove()})}updateCoordOverlay(e,t,r){if(!this.coordOverlayEl)return;const n=this.renderer.lastVertexCount>0?`${(this.renderer.lastVertexCount/1e3).toFixed(1)}K`:"-",s=this.renderer.lastIndexCount>0?`${(this.renderer.lastIndexCount/3e3).toFixed(1)}K`:"-";if(!r){this.coordOverlayEl.textContent=`x: -, y: -, zoom: ${this.scene.state.zoom.toFixed(2)}, verts: ${n}, tris: ${s}`;return}const a=this.renderer.canvas.getBoundingClientRect(),l=this.renderer.screenToWorld(e-a.left,t-a.top);this.coordOverlayEl.textContent=`x: ${l.x.toFixed(2)}, y: ${l.y.toFixed(2)}, zoom: ${this.scene.state.zoom.toFixed(2)}, verts: ${n}, tris: ${s}`}updateStats(e=!1){if(!this.fpsEl)return;const t=performance.now();if(!e&&t-this.lastStatsUpdate<250)return;this.lastStatsUpdate=t;const r=[`FPS: ${this.renderer.lastFps.toFixed(1)}`,`GPU Buffers: ${this.renderer.gpuBuffers.length} (${(this.renderer.gpuMemoryBytes/1048576).toFixed(2)} MB)`],n=performance;if(n.memory){const s=(n.memory.usedJSHeapSize/1048576).toFixed(2),a=(n.memory.totalJSHeapSize/1048576).toFixed(2);r.push(`JS Heap: ${s} / ${a} MB`)}this.fpsEl.innerHTML=r.join("<br/>")}}class G{constructor(e,t,r){i(this,"scene");i(this,"renderer");i(this,"ui");i(this,"canvas");i(this,"haveMouse",!1);i(this,"lastMouseX",0);i(this,"lastMouseY",0);i(this,"ZOOM_SPEED",.005);i(this,"MIN_ZOOM",.1);i(this,"MAX_ZOOM",500);this.scene=e,this.renderer=t,this.ui=r,this.canvas=t.canvas,this.setupListeners()}setupListeners(){this.canvas.style.touchAction="none",this.canvas.addEventListener("pointerdown",t=>{t.button!==0&&t.button!==1||(this.scene.state.dragging=!0,this.scene.state.dragButton=t.button,this.scene.state.lastX=t.clientX,this.scene.state.lastY=t.clientY,this.canvas.setPointerCapture(t.pointerId),this.canvas.style.cursor="grabbing")}),this.canvas.addEventListener("pointermove",t=>{if(this.lastMouseX=t.clientX,this.lastMouseY=t.clientY,this.haveMouse=!0,this.scene.state.dragging){const r=t.clientX-this.scene.state.lastX,n=t.clientY-this.scene.state.lastY;if(this.scene.state.lastX=t.clientX,this.scene.state.lastY=t.clientY,this.scene.state.dragButton===0||this.scene.state.dragButton===1){const s=window.devicePixelRatio||1;this.scene.state.panX+=r*s/this.scene.state.zoom,this.scene.state.panY-=n*s/this.scene.state.zoom,this.scene.state.needsDraw=!0}}this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)});const e=t=>{this.scene.state.dragging&&(this.scene.state.dragging=!1,this.scene.state.dragButton=null,this.canvas.hasPointerCapture(t.pointerId)&&this.canvas.releasePointerCapture(t.pointerId),this.canvas.style.cursor="grab")};this.canvas.addEventListener("pointerup",e),this.canvas.addEventListener("pointercancel",e),this.canvas.addEventListener("mouseleave",()=>{this.haveMouse=!1,this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)}),this.canvas.addEventListener("wheel",t=>{t.preventDefault();const r=this.canvas.getBoundingClientRect(),n=t.clientX-r.left,s=t.clientY-r.top,a=this.renderer.screenToWorld(n,s),l=Math.exp(-t.deltaY*this.ZOOM_SPEED);this.scene.state.zoom=this.clamp(this.scene.state.zoom*l,this.MIN_ZOOM,this.MAX_ZOOM);const B=Math.max(1,this.canvas.width),m=Math.max(1,this.canvas.height),x=this.scene.state.flipX?-1:1,o=this.scene.state.flipY?-1:1,b=2*this.scene.state.zoom/B,c=2*this.scene.state.zoom/m,f=2*n/Math.max(1,this.canvas.clientWidth)-1,d=1-2*s/Math.max(1,this.canvas.clientHeight);this.scene.state.panX=(f/x+1)/b-B/2-a.x,this.scene.state.panY=(1-d*o)/c-m/2-a.y,this.scene.state.needsDraw=!0,this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)},{passive:!1}),this.canvas.addEventListener("mousemove",()=>{this.scene.state.needsDraw=!0})}clamp(e,t,r){return Math.min(r,Math.max(t,e))}}const I=!!window.acquireVsCodeApi;I&&window.acquireVsCodeApi();async function Y(){const S=performance.now();console.log("[INIT] Starting initialization..."),console.log(`[INIT] Mode: ${I?"VS Code Extension":"Dev Server"}`);const e=document.getElementById("viewer");if(!(e instanceof HTMLCanvasElement))throw new Error("Canvas element #viewer was not found");const t=new P,r=new V(e,t),n=new R(t,r);await r.init(),new G(t,r,n),n.refreshLayerLegend(),n.updateStats(!0),t.state.needsDraw=!0;let s=[],a=null;const l=5;function B(){if(s.length===0)return;const o=performance.now();console.log(`[BATCH] Processing ${s.length} layers at once...`);for(const c of s)t.loadLayerData(c);n.refreshLayerLegend(),t.state.needsDraw=!0;const b=performance.now();console.log(`[BATCH] Loaded ${s.length} layers in ${(b-o).toFixed(1)}ms`),s=[],a=null}window.addEventListener("message",o=>{const b=performance.now(),c=o.data;if(c.command==="tessellationData"&&c.payload){const f=c.payload,d=performance.now();console.log(`[MSG] Received ${f.layerId} (parsed in ${(d-b).toFixed(1)}ms)`),s.push(f),a!==null&&clearTimeout(a),a=window.setTimeout(B,l)}else c.command==="error"&&console.error(`Extension error: ${c.message}`)});const m=performance.now();console.log(`[INIT] Total initialization time: ${(m-S).toFixed(1)}ms`);function x(){r.render(),n.updateStats(),requestAnimationFrame(x)}requestAnimationFrame(x)}Y().catch(S=>{console.error(S);const e=document.getElementById("ui");if(e){const t=document.createElement("div");t.style.marginTop="8px",t.style.color="#ff6b6b",t.textContent=S instanceof Error?S.message:String(S),e.appendChild(t)}});
