var M=Object.defineProperty;var I=(x,t,e)=>t in x?M(x,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):x[t]=e;var u=(x,t,e)=>(I(x,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();class O{constructor(){u(this,"state",{panX:0,panY:0,zoom:1,flipX:!1,flipY:!0,dragging:!1,dragButton:null,lastX:0,lastY:0,needsDraw:!0});u(this,"layerRenderData",new Map);u(this,"layerInfoMap",new Map);u(this,"layerOrder",[]);u(this,"layerColors",new Map);u(this,"layerVisible",new Map);u(this,"colorOverrides",new Map);u(this,"viasVisible",!0);u(this,"device",null);u(this,"pipelines",null);u(this,"uniformData",new Float32Array(16));u(this,"BASE_PALETTE",[[.95,.95,.95,1],[.95,.2,.2,1],[.2,.8,.2,1],[.3,.6,1,1],[1,.85,.2,1],[1,.4,.75,1],[.95,.55,.2,1],[.8,.3,1,1],[.2,.9,.9,1],[1,.6,.3,1],[.5,1,.3,1],[.3,.4,.8,1],[.9,.5,.7,1],[.7,.9,.5,1],[.5,.7,.9,1],[.9,.7,.4,1]]);u(this,"STORAGE_KEY","layerColorOverrides");this.loadColorOverrides()}setDevice(t,e){this.device=t,this.pipelines=e}getLayerColor(t){if(!this.layerColors.has(t)){const e=this.layerInfoMap.get(t);let n;e?n=[...e.defaultColor]:n=[...this.BASE_PALETTE[this.hashStr(t)%this.BASE_PALETTE.length]],this.colorOverrides.has(t)&&(n=[...this.colorOverrides.get(t)]),this.layerColors.set(t,n),this.layerVisible.has(t)||this.layerVisible.set(t,!0)}return this.layerColors.get(t)}setLayerColor(t,e){this.layerColors.set(t,e),this.colorOverrides.set(t,e),this.saveColorOverride(t,e),this.state.needsDraw=!0}resetLayerColor(t){this.layerColors.delete(t),this.colorOverrides.delete(t),this.removeColorOverride(t),this.state.needsDraw=!0}toggleLayerVisibility(t,e){this.layerVisible.set(t,e),this.state.needsDraw=!0}loadLayerData(t){const e=performance.now();if(!this.device||!this.pipelines){console.warn("Cannot load layer data: Device or pipelines not set");return}const n=t.layerId,r=t.layerName||n,s=[...t.defaultColor??[.8,.8,.8,1]];this.layerInfoMap.set(n,{id:n,name:r,defaultColor:s}),this.layerOrder.includes(n)||this.layerOrder.push(n),this.layerColors.has(n)||this.layerColors.set(n,[...s]),this.layerVisible.has(n)||this.layerVisible.set(n,!0);const a=[["batch",t.geometry.batch],["batch_colored",t.geometry.batch_colored],["batch_instanced",t.geometry.batch_instanced],["batch_instanced_rot",t.geometry.batch_instanced_rot],["instanced_rot_colored",t.geometry.instanced_rot_colored],["instanced_rot",t.geometry.instanced_rot],["instanced_colored",t.geometry.instanced_colored],["instanced",t.geometry.instanced],["basic",t.geometry.basic]];let d=!1;for(const[p,g]of a){if(!g||g.length===0)continue;d=!0;const o=p==="batch"?t.layerId:`${t.layerId}_${p}`;p==="instanced"||p==="instanced_rot"?this.loadInstancedGeometry(t,o,p,g):this.loadGeometryType(t,o,p,g)}d||console.warn(`No geometry data found for layer ${t.layerId}`);const b=performance.now();console.log(`[SCENE] Loaded ${t.layerId} in ${(b-e).toFixed(1)}ms`),this.state.needsDraw=!0}loadGeometryType(t,e,n,r){if(!this.device||!this.pipelines)return;const s=[],a=[],d=[],b=[],p=[];for(let f=0;f<r.length;f++){const i=r[f];if(!i)continue;let c;if(i.vertexData instanceof Float32Array)c=i.vertexData;else{const h=atob(i.vertexData),v=new Uint8Array(h.length);for(let B=0;B<h.length;B++)v[B]=h.charCodeAt(B);c=new Float32Array(v.buffer)}const C=this.device.createBuffer({size:c.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(C.getMappedRange()).set(c),C.unmap(),s.push(C),d.push(i.vertexCount);let w;if(i.alphaData)if(typeof i.alphaData=="object"&&i.alphaData instanceof Float32Array)w=i.alphaData;else{const h=atob(i.alphaData),v=new Uint8Array(h.length);for(let B=0;B<h.length;B++)v[B]=h.charCodeAt(B);w=new Float32Array(v.buffer)}else w=new Float32Array(i.vertexCount),w.fill(1);const y=this.device.createBuffer({size:w.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(y.getMappedRange()).set(w),y.unmap(),a.push(y),i.indexData&&i.indexCount&&i.indexCount>0){let h;if(i.indexData instanceof Uint32Array)h=i.indexData;else{const B=atob(i.indexData),E=new Uint8Array(B.length);for(let A=0;A<B.length;A++)E[A]=B.charCodeAt(A);h=new Uint32Array(E.buffer)}const v=this.device.createBuffer({size:h.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(v.getMappedRange()).set(h),v.unmap(),b.push(v),p.push(i.indexCount)}else b.push(null),p.push(0)}const g=this.getLayerColor(t.layerId);this.uniformData.set(g,0);const o=this.device.createBuffer({size:this.uniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=n==="batch"?this.pipelines.noAlpha:this.pipelines.withAlpha,l=this.device.createBindGroup({layout:m.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}}]});this.layerRenderData.set(e,{layerId:t.layerId,shaderType:n,lodBuffers:s,lodAlphaBuffers:a,lodVertexCounts:d,lodIndexBuffers:b,lodIndexCounts:p,currentLOD:0,uniformBuffer:o,bindGroup:l})}loadInstancedGeometry(t,e,n,r){if(!this.device||!this.pipelines)return;const s=[],a=[],d=[],b=[],p=[],g=[];for(let i=0;i<r.length;i++){const c=r[i];if(!c)continue;let C;if(c.vertexData instanceof Float32Array)C=c.vertexData;else{const y=atob(c.vertexData),h=new Uint8Array(y.length);for(let v=0;v<y.length;v++)h[v]=y.charCodeAt(v);C=new Float32Array(h.buffer)}const w=this.device.createBuffer({size:C.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(w.getMappedRange()).set(C),w.unmap(),s.push(w),d.push(c.vertexCount),c.instanceData&&c.instanceCount){let y;if(c.instanceData instanceof Float32Array)y=c.instanceData;else{const v=atob(c.instanceData),B=new Uint8Array(v.length);for(let E=0;E<v.length;E++)B[E]=v.charCodeAt(E);y=new Float32Array(B.buffer)}const h=this.device.createBuffer({size:y.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(h.getMappedRange()).set(y),h.unmap(),a.push(h),b.push(c.instanceCount)}else{const y=this.device.createBuffer({size:4,usage:GPUBufferUsage.VERTEX});a.push(y),b.push(0)}if(c.indexData&&c.indexCount&&c.indexCount>0){let y;if(c.indexData instanceof Uint32Array)y=c.indexData;else{const v=atob(c.indexData),B=new Uint8Array(v.length);for(let E=0;E<v.length;E++)B[E]=v.charCodeAt(E);y=new Uint32Array(B.buffer)}const h=this.device.createBuffer({size:y.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(h.getMappedRange()).set(y),h.unmap(),p.push(h),g.push(c.indexCount)}else p.push(null),g.push(0)}const o=this.getLayerColor(t.layerId);this.uniformData.set(o,0);const m=this.device.createBuffer({size:this.uniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),l=n==="instanced"?this.pipelines.instanced:this.pipelines.instancedRot,f=this.device.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}}]});this.layerRenderData.set(e,{layerId:t.layerId,shaderType:n,lodBuffers:s,lodInstanceBuffers:a,lodAlphaBuffers:[],lodVertexCounts:d,lodInstanceCounts:b,lodIndexBuffers:p,lodIndexCounts:g,currentLOD:0,uniformBuffer:m,bindGroup:f})}hashStr(t){let e=2166136261;for(let n=0;n<t.length;n+=1)e^=t.charCodeAt(n),e=Math.imul(e,16777619);return e>>>0}saveColorOverride(t,e){try{const n=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");n[t]=e,localStorage.setItem(this.STORAGE_KEY,JSON.stringify(n))}catch(n){console.error("Failed to save color override",n)}}removeColorOverride(t){try{const e=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");delete e[t],localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}catch(e){console.error("Failed to remove color override",e)}}loadColorOverrides(){try{const t=JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}");for(const[e,n]of Object.entries(t))Array.isArray(n)&&n.length===4&&(this.colorOverrides.set(e,[...n]),this.layerColors.set(e,[...n]))}catch(t){console.error("Failed to load color overrides",t)}}}const P=`// Basic shader for rendering simple shapes with optional per-vertex alpha\r
// Supports lines, arcs, outlines, polygons, polylines, fills\r
// Consolidated from: line.wgsl, arc.wgsl, outline.wgsl, polygon.wgsl, polyline.wgsl\r
// Alpha defaults to 1.0 (layer color) when no alpha buffer is provided\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) vertAlpha : f32) -> VSOut {\r
  var out : VSOut;\r
  let p = vec3<f32>(pos, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  // Combine layer RGB (from uniform) with per-vertex alpha\r
  out.color = vec4<f32>(U.color.xyz, vertAlpha);\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,F=`// Basic shader without per-vertex alpha (always uses layer color alpha)\r
// For rendering polylines and shapes that don't need transparency variation\r
// Optimized: no alpha buffer required, saves memory and attribute fetching\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>) -> VSOut {\r
  var out : VSOut;\r
  let p = vec3<f32>(pos, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  // Use layer color directly (RGB + A from uniform)\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,_=`// Instanced shader for rendering repeated identical geometry at different positions.\r
// Supports per-instance translation offset.\r
// Consolidated from: polygon_instanced.wgsl, polyline_instanced.wgsl\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) instOff : vec2<f32>) -> VSOut {\r
  var out : VSOut;\r
  // Apply per-instance translation in model space before view * model inside uniforms (we baked model*view already) -> instead, translate in clip by reconstructing before row multiply\r
  // Simpler: treat translation as added to position prior to matrix multiply (matrix encodes view, so we need to apply same linear part). We'll extend pos with 1 and rely on matrix rows.\r
  let p = vec3<f32>(pos + instOff, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`,T=`// Instanced shader with rotation support.\r
// For rendering repeated geometry at different positions with arbitrary rotations.\r
// Instance data: vec3<f32> = (offsetX, offsetY, rotationRadians)\r
\r
struct VSOut {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) color : vec4<f32>,\r
};\r
\r
struct Uniforms {\r
  color : vec4<f32>,\r
  m0 : vec4<f32>,\r
  m1 : vec4<f32>,\r
  m2 : vec4<f32>,\r
};\r
\r
@group(0) @binding(0) var<uniform> U : Uniforms;\r
\r
@vertex\r
fn vs_main(@location(0) pos : vec2<f32>, @location(1) inst : vec3<f32>) -> VSOut {\r
  var out : VSOut;\r
  \r
  // Extract rotation angle in radians\r
  let angle = inst.z;\r
  let c = cos(angle);\r
  let s = sin(angle);\r
  \r
  // Apply rotation\r
  let rotated = vec2<f32>(\r
    pos.x * c - pos.y * s,\r
    pos.x * s + pos.y * c\r
  );\r
  \r
  // Apply translation and transform\r
  let p = vec3<f32>(rotated + inst.xy, 1.0);\r
  let t = vec3<f32>( dot(U.m0.xyz, p), dot(U.m1.xyz, p), dot(U.m2.xyz, p) );\r
  out.Position = vec4<f32>(t.xy, 0.0, 1.0);\r
  out.color = U.color;\r
  return out;\r
}\r
\r
@fragment\r
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {\r
  return in.color;\r
}\r
`;class V{constructor(t,e){u(this,"canvas");u(this,"device");u(this,"context");u(this,"pipelineNoAlpha");u(this,"pipelineWithAlpha");u(this,"pipelineInstanced");u(this,"pipelineInstancedRot");u(this,"canvasFormat");u(this,"configuredWidth",0);u(this,"configuredHeight",0);u(this,"uniformData",new Float32Array(16));u(this,"lastVertexCount",0);u(this,"lastIndexCount",0);u(this,"frameCount",0);u(this,"lastFpsUpdate",performance.now());u(this,"lastFps",0);u(this,"scene");u(this,"gpuMemoryBytes",0);u(this,"gpuBuffers",[]);this.canvas=t,this.scene=e}async init(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not available in this browser");const e=await t.requestAdapter();if(!e)throw new Error("Unable to acquire WebGPU adapter");this.device=await e.requestDevice(),this.wrapCreateBuffer(this.device);const n=this.canvas.getContext("webgpu");if(!n)throw new Error("Failed to acquire WebGPU context");this.context=n,this.canvasFormat=t.getPreferredCanvasFormat(),this.createPipelines(),this.scene.setDevice(this.device,{noAlpha:this.pipelineNoAlpha,withAlpha:this.pipelineWithAlpha,instanced:this.pipelineInstanced,instancedRot:this.pipelineInstancedRot}),new ResizeObserver(()=>{this.configureSurface(),this.scene.state.needsDraw=!0}).observe(this.canvas),window.addEventListener("resize",()=>{this.configureSurface(),this.scene.state.needsDraw=!0})}createPipelines(){const t=this.device.createShaderModule({code:P}),e=this.device.createShaderModule({code:F}),n=this.device.createShaderModule({code:_}),r=this.device.createShaderModule({code:T});this.pipelineWithAlpha=this.device.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:1*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:1,offset:0,format:"float32"}]}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineNoAlpha=this.device.createRenderPipeline({layout:"auto",vertex:{module:e,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineInstanced=this.device.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x2"}]}]},fragment:{module:n,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}}),this.pipelineInstancedRot=this.device.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"float32x3"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}})}wrapCreateBuffer(t){if(t.__wrappedCreateBuffer)return;const e=t.createBuffer.bind(t);t.createBuffer=n=>{const r=e(n),s=n.size??0;return this.gpuMemoryBytes+=s,this.gpuBuffers.push({buffer:r,size:s}),r},t.__wrappedCreateBuffer=!0}configureSurface(){const t=window.devicePixelRatio||1,e=Math.max(1,Math.floor(this.canvas.clientWidth*t)),n=Math.max(1,Math.floor(this.canvas.clientHeight*t));this.canvas.width!==e&&(this.canvas.width=e),this.canvas.height!==n&&(this.canvas.height=n),!(e===this.configuredWidth&&n===this.configuredHeight)&&(this.configuredWidth=e,this.configuredHeight=n,this.context.configure({device:this.device,format:this.canvasFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT}))}updateUniforms(){const t=Math.max(1,this.canvas.width),e=Math.max(1,this.canvas.height),n=this.scene.state,r=n.flipX?-1:1,s=n.flipY?-1:1,a=2*n.zoom/t,d=2*n.zoom/e,b=a*(t/2+n.panX)-1,p=1-d*(e/2+n.panY);this.uniformData[4]=r*a,this.uniformData[5]=0,this.uniformData[6]=r*b,this.uniformData[7]=0,this.uniformData[8]=0,this.uniformData[9]=s*-d,this.uniformData[10]=s>0?p:-p,this.uniformData[11]=0,this.uniformData[12]=0,this.uniformData[13]=0,this.uniformData[14]=1,this.uniformData[15]=0}selectLODForZoom(t){return t>=10?0:t>=5?1:t>=2?2:t>=.5?3:4}screenToWorld(t,e){const n=Math.max(1,this.canvas.width),r=Math.max(1,this.canvas.height),s=this.scene.state,a=s.flipX?-1:1,d=s.flipY?-1:1,b=2*s.zoom/n,p=2*s.zoom/r,g=2*t/Math.max(1,this.canvas.clientWidth)-1,o=1-2*e/Math.max(1,this.canvas.clientHeight),m=(g/a+1)/b-n/2-s.panX,l=(1-o*d)/p-r/2-s.panY;return{x:m,y:l}}render(){if(!this.scene.state.needsDraw)return;this.scene.state.needsDraw=!1,this.configureSurface(),this.updateUniforms();const t=this.selectLODForZoom(this.scene.state.zoom),e=this.device.createCommandEncoder(),n=this.context.getCurrentTexture().createView(),r=e.beginRenderPass({colorAttachments:[{view:n,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});let s=0,a=0;for(const p of this.scene.layerOrder)if(this.scene.layerVisible.get(p)!==!1)for(const[g,o]of this.scene.layerRenderData.entries()){if(o.layerId!==p||g.endsWith("_instanced"))continue;if(o.shaderType==="instanced_rot"){const c=o.lodBuffers.length,C=c/3,w=t*C,y=w+C;r.setPipeline(this.pipelineInstancedRot);for(let h=w;h<y&&h<c;h++){const v=o.lodBuffers[h],B=o.lodVertexCounts[h],E=o.lodInstanceBuffers?.[h],A=o.lodInstanceCounts?.[h]??0;if(!v||!B||!E||A===0)continue;r.setVertexBuffer(0,v),r.setVertexBuffer(1,E);const D=this.scene.getLayerColor(o.layerId);this.uniformData.set(D,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),r.setBindGroup(0,o.bindGroup);const S=o.lodIndexBuffers?.[h],L=o.lodIndexCounts?.[h]??0;S&&L>0?(r.setIndexBuffer(S,"uint32"),r.drawIndexed(L,A),a+=L*A):r.draw(B,A)}continue}const m=Math.min(t,o.lodBuffers.length-1),l=o.lodBuffers[m],f=o.lodVertexCounts[m];if(!l||!f)continue;s+=f;let i;if(o.shaderType==="batch"?i=this.pipelineNoAlpha:g.endsWith("_instanced")?i=this.pipelineInstanced:i=this.pipelineWithAlpha,r.setPipeline(i),r.setVertexBuffer(0,l),g.endsWith("_instanced")){const c=o.lodInstanceBuffers?.[m],C=o.lodInstanceCounts?.[m]??0;if(c&&C>0){r.setVertexBuffer(1,c);const w=this.scene.getLayerColor(o.layerId);this.uniformData.set(w,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),r.setBindGroup(0,o.bindGroup);const y=o.lodIndexBuffers?.[m]??null,h=o.lodIndexCounts?.[m]??0;y&&h>0?(r.setIndexBuffer(y,"uint32"),r.drawIndexed(h,C),a+=h*C):r.draw(f,C)}}else{if(o.shaderType!=="batch"){const y=o.lodAlphaBuffers[m];y&&r.setVertexBuffer(1,y)}const c=this.scene.getLayerColor(o.layerId);this.uniformData.set(c,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),r.setBindGroup(0,o.bindGroup);const C=o.lodIndexBuffers?.[m]??null,w=o.lodIndexCounts?.[m]??0;C&&w>0?(r.setIndexBuffer(C,"uint32"),r.drawIndexed(w),a+=w):r.draw(f)}}const d=Array.from(this.scene.layerVisible.values()).some(p=>p);if(this.scene.viasVisible&&d){const p=[1,.9,.25,1];for(const[g,o]of this.scene.layerRenderData.entries()){if(!g.endsWith("_instanced"))continue;const m=o.lodBuffers.length,l=m/3;if(t>=3)continue;const f=t*l,i=f+l;for(let c=f;c<i&&c<m;c++){const C=o.lodBuffers[c],w=o.lodVertexCounts[c];if(!C||!w||w===0)continue;const y=o.lodInstanceBuffers?.[c],h=o.lodInstanceCounts?.[c]??0;if(!y||h===0)continue;r.setPipeline(this.pipelineInstanced),r.setVertexBuffer(0,C),r.setVertexBuffer(1,y),this.uniformData.set(p,0),this.device.queue.writeBuffer(o.uniformBuffer,0,this.uniformData),r.setBindGroup(0,o.bindGroup);const v=o.lodIndexBuffers?.[c]??null,B=o.lodIndexCounts?.[c]??0;v&&B>0?(r.setIndexBuffer(v,"uint32"),r.drawIndexed(B,h)):r.draw(w,h)}}}r.end(),this.device.queue.submit([e.finish()]),this.lastVertexCount=s,this.lastIndexCount=a,this.frameCount+=1;const b=performance.now();b-this.lastFpsUpdate>=1e3&&(this.lastFps=this.frameCount*1e3/(b-this.lastFpsUpdate),this.frameCount=0,this.lastFpsUpdate=b)}}class R{constructor(t,e){u(this,"scene");u(this,"renderer");u(this,"layersEl",null);u(this,"coordOverlayEl",null);u(this,"fpsEl",null);u(this,"debugLogEl",null);u(this,"lastStatsUpdate",0);this.scene=t,this.renderer=e,this.layersEl=document.getElementById("layers"),this.coordOverlayEl=document.getElementById("coordOverlay"),this.fpsEl=document.getElementById("fps"),this.debugLogEl=document.getElementById("debugLog"),this.interceptConsoleLog(this.debugLogEl)}interceptConsoleLog(t){t&&console.log("[LOGGING] Browser DevTools console is the primary log output")}refreshLayerLegend(){if(!this.layersEl)return;const t=[];t.push(`
      <div style="margin-bottom:4px; display:flex; gap:4px; flex-wrap:wrap; font:11px sans-serif;">
        <button type="button" data-layer-action="all" style="padding:2px 6px;">All</button>
        <button type="button" data-layer-action="none" style="padding:2px 6px;">None</button>
        <button type="button" data-layer-action="invert" style="padding:2px 6px;">Invert</button>
      </div>
    `);const e=this.scene.layerOrder.map(n=>[n,this.scene.getLayerColor(n)]);t.push("<div>");for(const[n,r]of e){const s=this.scene.layerVisible.get(n)!==!1;t.push(this.createLegendRow(n,r,s))}t.push("</div>"),this.layersEl.innerHTML=t.join(""),this.layersEl.querySelectorAll("button[data-layer-action]").forEach(n=>{n.addEventListener("click",r=>{const s=r.currentTarget.dataset.layerAction;if(s==="all")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,!0);else if(s==="none")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,!1);else if(s==="invert")for(const a of this.scene.layerColors.keys())this.scene.layerVisible.set(a,this.scene.layerVisible.get(a)===!1);this.refreshLayerLegend(),this.scene.state.needsDraw=!0})}),this.layersEl.querySelectorAll("input[data-layer-toggle]").forEach(n=>{n.addEventListener("change",r=>{const s=r.currentTarget,a=s.dataset.layerToggle;a&&this.scene.toggleLayerVisibility(a,s.checked)})}),this.layersEl.querySelectorAll("button[data-layer-color]").forEach(n=>{n.addEventListener("click",()=>{const r=n.dataset.layerColor;if(!r)return;const s=this.scene.getLayerColor(r);this.showColorPicker(r,s)})})}createLegendRow(t,e,n){const r=`rgba(${Math.round(e[0]*255)}, ${Math.round(e[1]*255)}, ${Math.round(e[2]*255)}, 1)`,s=this.scene.layerInfoMap.get(t),a=s?s.name:t;return`
      <div class="layer-entry" data-layer="${t}" style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
        <input type="checkbox" data-layer-toggle="${t}" ${n?"checked":""} style="margin:0" />
        <button type="button" data-layer-color="${t}" title="Change color" style="width:18px;height:18px;border:1px solid #444;border-radius:3px;background:${r};"></button>
        <span style="flex:1 1 auto; font-size:11px;">${a}</span>
      </div>
    `}showColorPicker(t,e){document.getElementById("colorPickerModal")?.remove();const r=document.createElement("div");r.id="colorPickerModal",r.style.cssText="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:10000;";const s=document.createElement("div");s.style.cssText="background:#2b2b2b; padding:20px; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.5);";const a=(l,f,i)=>`rgb(${Math.round(l*255)},${Math.round(f*255)},${Math.round(i*255)})`;let d=`<div style="color:#fff; font:14px sans-serif; margin-bottom:12px;">Pick color for <strong>${t}</strong></div>`;d+='<div style="display:grid; grid-template-columns:repeat(16, 24px); gap:2px; margin-bottom:12px;">';for(let l=0;l<16;l+=1){const f=l/15,i=a(f,f,f);d+=`<div class="color-cell" data-color="${f},${f},${f}" style="width:24px; height:24px; background:${i}; cursor:pointer; border:1px solid #444;"></div>`}for(let l=0;l<12;l+=1)for(let f=0;f<16;f+=1){const i=f/16*360,c=.3+l/11*.7,C=.3+f%2*.2+l%3*.15,w=(1-Math.abs(2*C-1))*c,y=w*(1-Math.abs(i/60%2-1)),h=C-w/2;let v=0,B=0,E=0;i<60?(v=w,B=y,E=0):i<120?(v=y,B=w,E=0):i<180?(v=0,B=w,E=y):i<240?(v=0,B=y,E=w):i<300?(v=y,B=0,E=w):(v=w,B=0,E=y),v+=h,B+=h,E+=h;const A=a(v,B,E);d+=`<div class="color-cell" data-color="${v},${B},${E}" style="width:24px; height:24px; background:${A}; cursor:pointer; border:1px solid #444;"></div>`}d+="</div>";const b=[0,1,2].map(l=>Math.round(e[l]*255).toString(16).padStart(2,"0")).join("");d+='<div style="display:flex; gap:10px; align-items:center; margin-bottom:12px;">',d+='<div style="color:#aaa; font:12px sans-serif;">Current:</div>',d+=`<div style="width:40px; height:24px; background:${a(e[0],e[1],e[2])}; border:1px solid #444;"></div>`,d+='<button id="resetColorBtn" style="padding:4px 10px; background:#555; color:#fff; border:none; border-radius:3px; cursor:pointer; font:11px sans-serif;">Reset to Default</button>',d+="</div>",d+='<div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">',d+='<div style="display:flex; gap:6px; align-items:center;">',d+='<label style="color:#aaa; font:11px sans-serif;">#</label>',d+=`<input type="text" id="hexColorInput" value="${b}" maxlength="6" style="width:80px; padding:6px 8px; background:#1a1a1a; color:#fff; border:1px solid #555; border-radius:3px; font:12px monospace; text-transform:uppercase;" />`,d+='<button id="applyCustomBtn" style="padding:6px 12px; background:#4a9eff; color:#fff; border:none; border-radius:3px; cursor:pointer; font:11px sans-serif;">Apply</button>',d+="</div>",d+='<button id="cancelColorBtn" style="padding:6px 14px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer; font:12px sans-serif;">Cancel</button>',d+="</div>",s.innerHTML=d,r.appendChild(s),document.body.appendChild(r),s.querySelectorAll(".color-cell").forEach(l=>{l.addEventListener("click",f=>{const i=f.currentTarget.dataset.color;if(!i)return;const[c,C,w]=i.split(",").map(parseFloat),y=[c,C,w,1];this.scene.setLayerColor(t,y),this.refreshLayerLegend(),r.remove()})});const p=document.getElementById("applyCustomBtn"),g=document.getElementById("hexColorInput");p?.addEventListener("click",()=>{if(!g)return;const l=g.value.replace(/[^0-9a-fA-F]/g,"");if(l.length===6){const f=parseInt(l.slice(0,2),16)/255,i=parseInt(l.slice(2,4),16)/255,c=parseInt(l.slice(4,6),16)/255,C=[f,i,c,1];this.scene.setLayerColor(t,C),this.refreshLayerLegend(),r.remove()}}),document.getElementById("resetColorBtn")?.addEventListener("click",()=>{this.scene.resetLayerColor(t),this.refreshLayerLegend(),r.remove()}),document.getElementById("cancelColorBtn")?.addEventListener("click",()=>r.remove()),r.addEventListener("click",l=>{l.target===r&&r.remove()})}updateCoordOverlay(t,e,n){if(!this.coordOverlayEl)return;const r=this.renderer.lastVertexCount>0?`${(this.renderer.lastVertexCount/1e3).toFixed(1)}K`:"-",s=this.renderer.lastIndexCount>0?`${(this.renderer.lastIndexCount/3e3).toFixed(1)}K`:"-";if(!n){this.coordOverlayEl.textContent=`x: -, y: -, zoom: ${this.scene.state.zoom.toFixed(2)}, verts: ${r}, tris: ${s}`;return}const a=this.renderer.canvas.getBoundingClientRect(),d=this.renderer.screenToWorld(t-a.left,e-a.top);this.coordOverlayEl.textContent=`x: ${d.x.toFixed(2)}, y: ${d.y.toFixed(2)}, zoom: ${this.scene.state.zoom.toFixed(2)}, verts: ${r}, tris: ${s}`}updateStats(t=!1){if(!this.fpsEl)return;const e=performance.now();if(!t&&e-this.lastStatsUpdate<250)return;this.lastStatsUpdate=e;const n=[`FPS: ${this.renderer.lastFps.toFixed(1)}`,`GPU Buffers: ${this.renderer.gpuBuffers.length} (${(this.renderer.gpuMemoryBytes/1048576).toFixed(2)} MB)`],r=performance;if(r.memory){const s=(r.memory.usedJSHeapSize/1048576).toFixed(2),a=(r.memory.totalJSHeapSize/1048576).toFixed(2);n.push(`JS Heap: ${s} / ${a} MB`)}this.fpsEl.innerHTML=n.join("<br/>")}}class G{constructor(t,e,n){u(this,"scene");u(this,"renderer");u(this,"ui");u(this,"canvas");u(this,"haveMouse",!1);u(this,"lastMouseX",0);u(this,"lastMouseY",0);u(this,"ZOOM_SPEED",.005);u(this,"MIN_ZOOM",.1);u(this,"MAX_ZOOM",500);this.scene=t,this.renderer=e,this.ui=n,this.canvas=e.canvas,this.setupListeners()}setupListeners(){this.canvas.style.touchAction="none",this.canvas.addEventListener("pointerdown",e=>{e.button!==0&&e.button!==1||(this.scene.state.dragging=!0,this.scene.state.dragButton=e.button,this.scene.state.lastX=e.clientX,this.scene.state.lastY=e.clientY,this.canvas.setPointerCapture(e.pointerId),this.canvas.style.cursor="grabbing")}),this.canvas.addEventListener("pointermove",e=>{if(this.lastMouseX=e.clientX,this.lastMouseY=e.clientY,this.haveMouse=!0,this.scene.state.dragging){const n=e.clientX-this.scene.state.lastX,r=e.clientY-this.scene.state.lastY;if(this.scene.state.lastX=e.clientX,this.scene.state.lastY=e.clientY,this.scene.state.dragButton===0||this.scene.state.dragButton===1){const s=window.devicePixelRatio||1;this.scene.state.panX+=n*s/this.scene.state.zoom,this.scene.state.panY-=r*s/this.scene.state.zoom,this.scene.state.needsDraw=!0}}this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)});const t=e=>{this.scene.state.dragging&&(this.scene.state.dragging=!1,this.scene.state.dragButton=null,this.canvas.hasPointerCapture(e.pointerId)&&this.canvas.releasePointerCapture(e.pointerId),this.canvas.style.cursor="grab")};this.canvas.addEventListener("pointerup",t),this.canvas.addEventListener("pointercancel",t),this.canvas.addEventListener("mouseleave",()=>{this.haveMouse=!1,this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)}),this.canvas.addEventListener("wheel",e=>{e.preventDefault();const n=this.canvas.getBoundingClientRect(),r=e.clientX-n.left,s=e.clientY-n.top,a=this.renderer.screenToWorld(r,s),d=Math.exp(-e.deltaY*this.ZOOM_SPEED);this.scene.state.zoom=this.clamp(this.scene.state.zoom*d,this.MIN_ZOOM,this.MAX_ZOOM);const b=Math.max(1,this.canvas.width),p=Math.max(1,this.canvas.height),g=this.scene.state.flipX?-1:1,o=this.scene.state.flipY?-1:1,m=2*this.scene.state.zoom/b,l=2*this.scene.state.zoom/p,f=2*r/Math.max(1,this.canvas.clientWidth)-1,i=1-2*s/Math.max(1,this.canvas.clientHeight);this.scene.state.panX=(f/g+1)/m-b/2-a.x,this.scene.state.panY=(1-i*o)/l-p/2-a.y,this.scene.state.needsDraw=!0,this.ui.updateCoordOverlay(this.lastMouseX,this.lastMouseY,this.haveMouse)},{passive:!1}),this.canvas.addEventListener("mousemove",()=>{this.scene.state.needsDraw=!0})}clamp(t,e,n){return Math.min(n,Math.max(e,t))}}function $(x){const t=new DataView(x);let e=0;console.log(`[BinaryParser] Buffer size: ${x.byteLength}, first 32 bytes:`,new Uint8Array(x,0,Math.min(32,x.byteLength)));const n=new TextDecoder().decode(new Uint8Array(x,e,8));if(console.log(`[BinaryParser] Magic header: "${n}"`),n!=="IPC2581B")throw new Error(`Invalid binary format: expected magic "IPC2581B", got "${n}"`);e+=8;const r=t.getUint32(e,!0);e+=4;const s=new TextDecoder().decode(new Uint8Array(x,e,r));e+=r;const a=(4-r%4)%4;e+=a;const d=t.getUint32(e,!0);e+=4;const b=new TextDecoder().decode(new Uint8Array(x,e,d));e+=d;const p=(4-d%4)%4;e+=p;const g=[t.getFloat32(e,!0),t.getFloat32(e+4,!0),t.getFloat32(e+8,!0),t.getFloat32(e+12,!0)];e+=16;const o=Y(x,e);return{layerId:s,layerName:b,defaultColor:g,geometry:o}}function Y(x,t){const e=new DataView(x);let n=t;const r={},s=e.getUint32(n,!0);if(n+=4,s>0){const b=[];for(let p=0;p<s;p++){const g=e.getUint32(n,!0);n+=4;const o=e.getUint32(n,!0);n+=4;const m=g*2,l=new Float32Array(x,n,m);n+=m*4;let f;o>0&&(f=new Uint32Array(x,n,o),n+=o*4),b.push({vertexCount:g,indexCount:o>0?o:void 0,vertexData:l,indexData:f})}r.batch=b}const a=e.getUint32(n,!0);if(n+=4,a>0){const b=[];for(let p=0;p<a;p++){const g=e.getUint32(n,!0);n+=4;const o=e.getUint32(n,!0);n+=4;const m=e.getUint8(n)===1;n+=1,n+=3;const l=g*2,f=new Float32Array(x,n,l);n+=l*4;let i;o>0&&(i=new Uint32Array(x,n,o),n+=o*4);let c;m&&(c=new Float32Array(x,n,g),n+=g*4),b.push({vertexCount:g,indexCount:o>0?o:void 0,vertexData:f,indexData:i,alphaData:c})}r.batch_colored=b}const d=e.getUint32(n,!0);if(n+=4,d>0){const b=[];for(let p=0;p<d;p++){const g=e.getUint32(n,!0);n+=4;const o=e.getUint32(n,!0);n+=4;const m=e.getUint32(n,!0);n+=4;const l=g*2,f=new Float32Array(x,n,l);n+=l*4;let i;o>0&&(i=new Uint32Array(x,n,o),n+=o*4);let c;m>0&&(c=new Float32Array(x,n,m*3),n+=m*3*4),b.push({vertexCount:g,indexCount:o>0?o:void 0,instanceCount:m>0?m:void 0,vertexData:f,indexData:i,instanceData:c})}r.instanced_rot=b}return r}const U=!!window.acquireVsCodeApi;U&&window.acquireVsCodeApi();async function z(){const x=performance.now();console.log("[INIT] Starting initialization..."),console.log(`[INIT] Mode: ${U?"VS Code Extension":"Dev Server"}`);const t=document.getElementById("viewer");if(!(t instanceof HTMLCanvasElement))throw new Error("Canvas element #viewer was not found");const e=new O,n=new V(t,e),r=new R(e,n);await n.init(),new G(e,n,r),r.refreshLayerLegend(),r.updateStats(!0),e.state.needsDraw=!0;let s=[],a=null;const d=0;function b(){if(s.length===0)return;const o=performance.now();console.log(`[BATCH] Processing ${s.length} layers at once...`);for(const l of s)e.loadLayerData(l);r.refreshLayerLegend(),e.state.needsDraw=!0;const m=performance.now();console.log(`[BATCH] Loaded ${s.length} layers in ${(m-o).toFixed(1)}ms`),s=[],a=null}window.addEventListener("message",async o=>{const m=performance.now(),l=o.data;if(l.command==="binaryTessellationData"&&l.binaryPayload){const f=l.binaryPayload;console.log(`[MSG] Binary payload size: ${f.byteLength} bytes`);const i=performance.now(),c=$(f),C=performance.now(),w=performance.now();console.log(`[MSG] Received binary ${c.layerId} (parsed in ${(C-i).toFixed(1)}ms, total: ${(w-m).toFixed(1)}ms)`),s.push(c),a!==null&&clearTimeout(a),a=window.setTimeout(b,d)}else if(l.command==="tessellationData"&&l.payload){const f=l.payload,i=performance.now();console.log(`[MSG] Received JSON ${f.layerId} (parsed in ${(i-m).toFixed(1)}ms)`),s.push(f),a!==null&&clearTimeout(a),a=window.setTimeout(b,d)}else l.command==="error"&&console.error(`Extension error: ${l.message}`)});const p=performance.now();console.log(`[INIT] Total initialization time: ${(p-x).toFixed(1)}ms`);function g(){n.render(),r.updateStats(),requestAnimationFrame(g)}requestAnimationFrame(g)}z().catch(x=>{console.error(x);const t=document.getElementById("ui");if(t){const e=document.createElement("div");e.style.marginTop="8px",e.style.color="#ff6b6b",e.textContent=x instanceof Error?x.message:String(x),t.appendChild(e)}});
